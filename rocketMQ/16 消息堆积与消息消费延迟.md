# 消息堆积与消息消费延迟

当消息消费者对消息的消费能力远远差于消息生产的效率时，**消息将会产生积压从而产生消息消费延迟**

## 消息堆积的原因

#### 客户端拉取消息

rocketMQ拉取消息放入本地队列是很快的，内网单线程的效率可以达到几万TPS，如果并行可以轻松达到几十万TPS，所以拉取消息不是消息堆积的原因

#### 客户端处理消息

此处是客户端从本地队列获取到一条条消息进行处理，业务逻辑中，主要耗费的时间是在写数据库、写缓存、写文件、远程PRC调用等IO耗时上，如果能够知道这些操作的耗时，就可以知道具体业务处理话费多少时间了

## 消费并发度

对于普通消息、延迟消息、事务消息，他们的并发度等于**单节点线程数*节点数量**

对于顺序消息，它的并发度等于**topic的queue分区**数量

全局顺序消息，一个topic只有一个queue，它的消息并发度是1

分区顺序消息，并发度等于**topic的queue分区**数量

## 如何避免与处理？

事先：

计算出消息消费的耗时（RPC、写DB、硬盘IO等等），和预估消息生产者的生产能力（这个有可能不太准），然后决定queue的数量和消费者的数量，尽量避免出现消息积压的问题。

事中：

如果已经出现了消息积压，那么根据业务可以有以下几种解决方案：

**消息允许丢弃**：这个种情况，修改代码，**将消息丢弃即可**，但是往往消息是不能丢弃的，此时根据队列的数量和消费者的数量来解决

**队列大于消费者数量**：这种情况下，由于存在着多个队列被一个消费者消费的情况，可以**尝试增加消费者数量**直到与队列数量相等，让每一个消费者负责一个队列从而提升消费能力（幂等性是肯定要的，rebalance可能出现重复消费）

**队列等于消费者数量**：这种情况下增加消费者数量无济于事，因为**一个队列只能被一个消费者消费**。如果增加消费者内部业务处理线程数管用的话，**可以考虑将业务处理线程数调高**。如果不好用可以使用以下终极解决方案：

1. 新建一个临时topic，这个topic下有很多的queue，同时启动很多个临时消费者（业务逻辑保持和旧的一样）消费这个topic（一对一是最好的）
2. 修改原topic消费者的消费代码，拿到消息之后不做任何处理，直接投递到临时topic，这一步因为不需要做业务处理所以非常快
3. 这样就可以快速消费原topic积压的消息了

## 消息的清理

消息消费过后并不会被清理。

消息的清理不可能按照以消息为纬度来进行清理，因为消息不定长，清理起来效率极低。所以**消息清理是以commitlog为单位**进行清理的。

commitlog文件存在一个过期时间，默认为72小时，除了用户主动清理以外，以下情况也会被清理：

1. 文件过期，且到达清理时间点（默认为凌晨4点），自动清理过期文件
2. 文件过期，且磁盘占用空间超过警戒线（默认75%），无论是否到达清理时间点，都会自动清理过期文件
3. 磁盘占用率达到警戒线（默认85%），不管有没有过期，都会进行文件清理，默认从最老的开始
   1. 磁盘占用率到达危险线（默认90%），broker拒绝消息写入
