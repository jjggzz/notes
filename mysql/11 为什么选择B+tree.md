# 为什么选择B+tree

由于数据存储在硬盘，所往往减少磁盘IO次数会比优化算法复杂度收益要高，所以在这种根磁盘IO相关的场景，IO次数少的算法能够胜出。

## 线性表

由于线性表得一个一个地加载数据进行寻找，效率太低故没什么选择的必要。

## Hash表

Hash表利用hash函数将要存储的数据放到对应的位置，当需要进行查找时只需要进行一次hash值的计算就可以快速找到对应的位置，访问效率为O(1)，性能比线性表好很多。

## 树形

按照一定的规则构建树（比如左子结点永远小于父结点，右子结点永远大于父结点），这样，寻找数据的时候就可以快速在树中移动，以便查找。大多数树形结构的查找效率为O($log_{2}n$)，效率低于hash表但是高于线性表。

## 为什么采用树形结构

但是为什么mysql要采用树形结构来构建索引，而不是用Hash呢？

这是因为：

1. Hash在等值匹配的时候有很好的性能，而对于范围查询则依旧得一个一个地进行匹配，而树形结构则可以快速进行范围查找（本身树形结构可以是有序的）
2. 如果有排序需求Hash获取到数据后还需要进行一次排序
3. 如果是联合索引，那么Hash无法使用左前缀匹配，只能全值匹配。
4. 如果hash冲突多，则效率退化为O(n)

## B+tree与B-tree的区别

1. B+tree的子结点数量=当前结点元素数量，B-tree的子结点数量=当前结点元素数量+1

   B+tree子结点存父结点的值，B-tree存空位（父结点中断的值）

2. B+tree非叶子结点不存值，B-tree非叶子结点也存值

3. B+tree叶子结点存有了全部的值，B-tree的叶子结点并没有存储全部的值

为什么mysql采用B+tree：

1. B+tree相比较B-tree，在每页限定16K的情况下，B+tree可以有更多子页（非叶子结点不存数据）
2. 所有值都存储在叶子结点，范围搜索遍历会更快（B-tree需要中序遍历）
3. B+tree搜索效率更稳定

## 搜索时间在O($log_{2}n$)的数据结构有很多，为什么不用他们？

1. 线性表，排序的基础上使用二分查找，由于数据在磁盘中，需要进行O($log_{2}n$)磁盘IO
2. 二叉搜索树，在数据偏斜的情况下最差为O(n)，O(n)次磁盘IO伤不起，就算是最好情况也要O($log_{2}n$)磁盘IO，并且范围查询不好做，需要做中序遍历（左根右）
3. 红黑树，高度可以维持在$log_{2}n$级别，但是会有各种变形，移位等操作，这些如果在磁盘中做那将是灾难
4. 跳表，比前面几个稍微好一点，但是还是由于高度问题，需要多次的磁盘IO，并且如果升层需要更多次数的IO

有了这些原因就决定了层数多，搜索时间不稳定的数据结构无法作为数据库索引的实现，需要一种更加扁平的数据结构B+tree就非常适合

