# 锁的类型

从操作类型上可以大致分为：读锁/共享锁，写锁/排他锁

从锁的粒度上可大致分为：表级锁（表级s锁/x锁，意向锁，自增锁，MDL锁），页级锁，行级锁（Record Locks，Gap Locks，Next-Key Locks，插入意向锁）

从锁的态度上可分为：悲观锁，乐观锁

从加锁方式上可分为：隐式锁，显式锁

## 操作类型层面

读锁又称共享锁（share lock，S锁），写锁又称排他锁（exclusive lock，X锁）

|      | S锁            | X锁  |
| ---- | -------------- | ---- |
| S锁  | 同时进入临界区 | 阻塞 |
| X锁  | 阻塞           | 阻塞 |

在mysql中为读数据加锁的方式入下：

```sql
## 为查询的数据加共享锁
SELECT ... lock in share mode;
## 为查询的数据加排他锁（锁定读）
SELECT ... for update;
```

对于insert，update，delete等操作加锁情况如下：

insert：插入数据一般不加锁，只是通过隐式锁进行保护，保证这条数据在提交前不会被其他事务访问

delete：删除数据时，先在B+tree中定位到数据到位置，然后对该数据加排他锁，然后将数据的delete_mask修改为1

update：修改时情况比较复杂

- 不对主键进行修改，并且修改的内容不会引起占用空间的变化，先在B+tree中定位到数据到位置，然后对该数据加排他锁，然后进行修改
- 不对主键进行修改，但是修改的内容超过了当前数据占用的大小，先在B+tree中定位到数据到位置，然后对该数据加排他锁，将该记录彻底删除掉（加入垃圾链表），最后插入一条新记录，插入记录的insert操作由隐式锁保护
- 修改主键的值，先做delete过程，再做insert过程

## 粒度层面

### 表级层面

表级层面的**共享锁**与排他锁很好理解，就是在普通的共享锁与排他锁的要求下将锁的范围扩大到整个表

```sql
## 给表xxx加读锁
lock tables xxx read;
## 给表xxx加写锁
lock tables xxx write;
```

不管是读锁还是写锁加锁后只能操作这张表，不允许操作其他表

**意向锁**是为了解决这样一个场景：当想要给表A加表级锁时，为**了保证一致性，需要对表中所有的数据都进行判断**，只有在表中所有的数据都没有竞争关系的时候才能够加表级锁，这种情况下无疑是**效率极低**的，有一种办法是在**给行记录进行加锁的同时，在表级层面加上一把意向锁**（如果是共享锁，那么加的是共享意向锁，如果是排他锁，加的是排他意向锁），这样在给**表加锁时就可以简单与意向锁做判断**即可，不需要访问表中数据行。**意向锁只会与表级锁有竞争关系，意向锁之间不会有竞争关系**，意向锁的出现是为了提高并发事务下加锁的效率

**MDL锁**全称MetaData Lock元数据锁，它是一个表级锁，在innodb中select、delete、update、insert这些语句会自动加上MDL的读锁（有点意向锁的意思），alert table、drop table等DDL语句会尝试为表加上MDL的写锁，MDL的读写锁之间会互斥

**自增锁**mysql在定义表时可以为字段设置自增属性，使它能够自动增长，由于存在多个事务并发的情况，所以对于自增的实现，需要表级锁来实现

### 行级锁

**Record Locks**记录锁，没啥好说的，就是两种，共享锁与间隙锁，都是作用于记录之上，行为与传统的共享锁和间隙锁一致，使用它可以解决脏读和不可重复读的问题。

**Gap Locks**间隙锁，的意思就是对某个间隙进行加锁操作，使其它事务不能够往这个间隙中新增数据，从而达到解决幻读的问题，具体行为如下：

| 1    | 5    | 10   | 15   | 20   |
| ---- | ---- | ---- | ---- | ---- |
| 18   | 18   | 18   | 18   | 18   |
| zs   | ls   | ww   | zl   | tq   |

如果事务A对1-5这个区间内部的某个不存在的id进行一次当前读（不管是加共享锁的读还是排他锁的读），则会对1-5这个区间范围内加间隙锁，使得其他事务在这个区间内无法进行数据插入操作（比如查询id等于4的值，会导致其他事务无法进行id为2或3的插入）

如果事务A使用当前读对某个id为25的数据（该数据不存在），那么会对20-+∞这个加间隙锁，使得其他事务进行的主键大于20的插入行为阻塞。

**Next-Key Locks**临键锁，临键锁=记录锁+间隙锁，间隙锁是一个开区间，不包含边界，而临键锁不仅会对区间进行锁定，还会对查找到的记录进行锁定。

**在唯一索引中，进行等值匹配，如果查找的值存在则加行锁，如果记录不存在则加间隙锁**

**在唯一索引中，进行范围查询，匹配的行会被加行锁，条件中的其他区域会被加间隙锁（间隙锁的的范围都是从已存在的数据得出的，跟查询条件无关），从而形成临键锁**

**在普通索引中，不管查询到的是单条记录还是多条记录，都加间隙锁，其锁定范围除了匹配的行外，还有左右两个区间（避免其他事务插入匹配的数据导致出现的幻读）**

**如果不在索引上进行查询，则会产生表锁**

**上述的查询都是指当前读**

**插入意向锁**，当某个事物对某个区间加间隙锁之后，其他企图往这个区间内插入数据的行为会被阻塞，阻塞的时候也会加上一把锁，这把锁叫插入意向锁（与表级的意向锁不是一个概念），插入意向锁之间并不会互斥，只要间隙锁释放，则插入成功，例如：

1. 事务A对区间(10,20)加间隙锁
2. 事务B企图插入id为15的数据，事务B被阻塞，事务B加插入意向锁
3. 事务C企图插入id为16的数据，事务C被阻塞，事务C加插入意向锁
4. 事务A释放该间隙锁
5. 事务B、事务C都插入成功

需要注意的是，mysql的锁空间是有大小限制的，当加锁数量超过阈值，那么就会进行锁升级，采用更粗粒度的锁代替多个小粒度的锁，这样占用的空间就小了，但是并发度会下降