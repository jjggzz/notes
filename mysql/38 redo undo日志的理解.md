# redo undo日志的理解

事务的隔离性由锁机制实现。

事务的原子性、持久性、一致性由redo log、undo log日志实现

1. redo log称为重做日志，提供再写入操作，恢复提交事务修改的页操作，保证事务的持久性
2. undo log称为回滚日志，回滚记录到某个特定的版本，用来保证事务的原子性，一致性

其实redo log和undo log并不是互逆的，redo log记录的是关于页的修改，记录的是物理磁盘上某个页的某个偏移量写入了某个数据。而undo log记录的是逻辑操作日志，比如说是对某个insert语句记录一条相反的delete语句，某个update语句记录修改回原值的update语句，主要用于事务回滚。

**redo log和undo log都是存储引擎（innodb）级别的日志，由存储引擎写入**

## redo log日志

为了保证事务的**持久性**，mysql需要有一种方式将数据从内存写入磁盘。我们知道，mysql对数据的修改都是在内存中的buffer pool中完成的，由于内存的特性，断电后数据丢失，所以不满足持久性，为了保证持久性，**mysql会定期的将buffer pool中的数据刷入磁盘**。但是这样还是会存在数据丢失的问题（事务commit了，但是还没有刷盘，mysql宕机了），所以有以下方式可以解决这一问题。

1. 在commit的时候就进行磁盘的写操作，这样只要一提交则数据立刻持久化。

   但是这样做会有一些问题：

   1. **写放大**：mysql对于数据的读写都是以页为单位的，默认16k，如果我只修改1个字节的内容，那么就会对磁盘写入16k数据，这种情况被称为写放大
   2. **大量随机io**：由于并不知道事务中会操作那些数据，很多情况下操作的数据都分布在不同的数据页中，那么在进行写磁盘的时候就是随机io，而随机io的效率极低

   上述的两个问题我们知道，**commit的时候实时刷盘会存在严重的性能问题**（内存读写效率与磁盘读写效率相差过远，并且没有利用上引入buffer pool带来的io优势）

2. 对于提交的事务，记录其修改的内容以追加的方式（顺序io）记录到另外一个文件中（称为redo log日志文件），定期刷盘的策略不变，mysql重启的时候，读取该日志文件进行重放，保证事务的持久性

   这样做会有一些好处：

   1. 充分利用了buffer pool的优势（内存IO），数据写入内存，定期将内存中的脏页（和磁盘数据不一致的页）刷到磁盘
   2. 由于以追加的方式将修改写入日志文件，随机io变为顺序io，效率高，这种工作模式被称为WAL（write-ahead logging）写前日志

## redo构成

redo log由两部分组成，一部分是内存中的redo log buffer，一部分是硬盘中的redo log file。

其中redo log buffer这块内存的默认大小是16M，最大值是4096M最小值是1M。redo log buffer被分为若干个连续多redo log block，每个block占512字节，block又分为block header、body、block trailer。

redo log file为持久化文件，它在数据目录下，默认情况下它有两个，ib_logfile0、ib_log file1，redo log file单个文件默认大小为48M，最大允许512G（文件数*单个文件大小），数据恢复时，从这两个文件中恢复

## redo log保存流程

一个事务的执行数据持久化的流程大致如下：

1. 将需要修改的数据的页从磁盘中加载到data buffer pool中
2. 对数据页进行修改，每执行一条修改指令，则记录一条重做日志到redo log buffer中，记录的是数据修改后的值
3. **事务commit时将redo log buffer的内容刷盘到redo log file中（顺序写）**
4. 定期将data buffer pool中的脏页写入磁盘

这里的第3步，redo log buffer写数据到redo log file中有多种策略（**这里所谓的刷盘不是直接写磁盘，而是指写入page cache（文件系统缓存），然后再从page cache写入磁盘**）

所以这里有一个参数控制刷盘的策略innodb_flush_log_at_trx_commit：

- 设置为0时：每次事务提交时不进行磁盘同步，只会将修改写入redo log buffer（系统默认的master thread每隔1s进行一次redo log的同步）（**最快，但是最不安全，如果mysql突然宕机有可能丢失前1s提交的事务数据**）
- 设置为1时：每次事务提交时都进行磁盘同步（默认值）（**最安全，但是最慢，每次事务提交都进行磁盘同步**）
- 设置为2时：表示每次事务提交时都只把redo log buffer中的内容写入page cache，不进行同步。具体什么时候写入磁盘由操作系统决定（**比0安全，只要操作系统不宕机提交的事务就不会丢失**）

## 写入redo log buffer过程

mini-transaction，简称mtr，它代表mysql对底层页面的一次原子访问（比如向B+tree中插入一条记录），一个mtr可能对应一组redo日志（因为该操作可能涉及到页分裂等操作，会影响多个数据页），在进行崩溃恢复时，这一组redo日志是原子的。

一个事务可能包含多条语句，一条语句可能由多条mtr组成，一个mtr操作可能生成一组redo日志。

由于redo log buffer是顺序写入的，所以innodb提供了一个名为buf_free的全局变量记录当前redo log buffer现在正在写入的位置。

由于一个mtr生成的一组redo日志是原子的，所以在写入时，这些redo日志并不是一条一条写入的，而是先存放在某个地方，写入buffer时一次性写入一组。

**由于事务是并发执行的，所以，一个事务中所产生的所有redo日志可能不是连续的，但是一个mtr产生的redo日志一定是连续的，放在一起的**

## 写入redo log file过程

redo log file中有两个指针，一个为write pos，这个指针表示当前文件的写入位置，另一个为checkpoint，这个指针表示，当前数据已刷盘的位置，默认情况下文件redo log file大小为96M（48 * 2）每当有日志内容写入write pos向后移动，每当对数据进行持久化（注意是数据，不是日志），checkpoint向后移动，**这里我们可以redo log file看成是一个首尾相连的环型，checkpoint和write pos之间的内容为有效redo日志**。

- 当checkpoint追上write pos，代表数据全部都刷入了磁盘，不存在有效redo日志
- 当write pos追上了checkpoint（超出一圈），代表了redo log  file中所有空间都是有效redo日志，此时无法继续写入，需要对数据进行持久化，并移动checkpoint

## undo log日志

为了保证事务的原子性，事务中在更新数据之前会写入一个undo日志，在需要时使用它做数据回滚操作。

## undo log日志的理解

为了保证事务的原子性，有时候可能在事务执行过程中出错，或者人为的手动rollback。此时需要将数据恢复原样，让其看起来就和执行事务之前一样。

每当我们对一条记录进行操作时（更新操作，insert、delete、update），都记录其相仿操作

- insert时，记录其delete语句，回滚时使用它将新增的数据删除
- delete时，记录原来记录的数据为insert语句，回滚时使用它将删除的数据找回来
- update时，记录被修改字段的原值，在回滚时使用它将数据恢复成修改之前

mysql把这些日志称为undo日志，对于查询并不会进行相反的操作，因为它不会造成数据的变化，另外**undo日志的产生也会产生相应的redo日志**，因为它也需要进行持久化保护（考虑一种情况，事务执行到一半，数据修改了一部分，此时事务没有提交，但是因为后台线程是异步的关系，刷了一部分数据页到磁盘中，数据修改的redolog也写了，undolog也写了一部分，然后突然断电。我们知道重启时，mysql根据redolog进行数据恢复，假如redolog中没有记录undolog那么会丢失一部分undolog文件的内容，那么它就没法回滚那些执行到一半未提交的事务造成的脏数据了。如果记录了写undolog的操作，那么在重启时，重放redolog进行刷盘，然后再读取undolog将可能需要回滚的数据进行回滚。）

## undo日志的作用

undo日志的回滚操作并不是物理上将数据结构回溯到事务未开始之前，只是通过一些操作使数据看起来像之前一样，比如说一个插入操作，有可能开辟了一个新的页，此时，如果发生回滚，mysql会删除这条数据，但是数据页不会进行删除，因为此时可能其他的并发事务正在写该页。

undolog还有一个作用就是MVCC多版本并发控制，当某条数据被其他事务占用，当前事务可以通过undo日志获取到之前的行版本信息，以此实现非锁定读取。（可重复读的实现）

## undo日志的存储结构

undo日志采用段进行存储，称为回滚段rollback segment，每个回滚段支持1024个undo log segment，在undo log  segment中进行undo页的申请。

Innodb1.1之后支持128个回滚段，也就是说支持1024 * 128（0预留在系统表空间，1-32在临时表空间，33-127在独立表空间或者ibdata中）个事务同时在线。

undo页是可以重用的，当某个事务提交后如果该页的使用空间不到页大小的3/4，则认为该页是可以给其他事务重用。因此undolog是离散的，清理对应磁盘空间时效率不高。

1. 每个事务只会使用一个回滚段，一个回滚段可能服务多个事务。
2. 当一个事务开始时会制定一个回滚段，在事务执行过程中，当数据被修改时，原始数据会被复制到回滚段
3. 在回滚段中事务会不断填充盘区，直到事务结束，或者空间被用完，如果当前盘区不够用事务会在 段中请求拓展下一个盘区，如果所有已分配的盘区都被使用完，事务会覆盖最初的盘区或者在回滚段允许的情况下拓展新的盘区来使用。
4. 回滚段存在于undo表空间中，undo表空间可以有多个（最少是两个），但一次只能使用一个undo表空间。
5. 当事务提交的时候innodb会做两件事：将undo log放入列表中，供后续的purge操作。判断undo log所在的页是否可重用，若可以，则分配给下一个事务使用

### 回滚段中的数据分类

1. 未提交的回滚数据：该数据关联的事务并未提交，为了读一致性，该数据不能被其他事务的undo日志覆盖
2. 已提交但未过期的回滚数据：该数据关联的事务已经提交，但受mysql参数的影响数据并未过期
3. 事务已提交并过期的数据：没啥好说的，可以被其他事务的undo日志覆盖

事务提交后并不能马上清理该事务的undo log和该undo log所在的页，因为MVCC的原因可能还有其他事务正在读取该版本的数据。所以事务提交后将undo log放入一个链表中，是否可以删除有purge来判断

### undo的类型

分为两种，insert语句产生的undo日志，在事务提交后可以直接删除（因为insert只对本事务可见），update和delete产生的undo日志需要放入一个链表中，由purge来决定是否删除（因为MVCC的原因，其他事务可能正好在用着）

