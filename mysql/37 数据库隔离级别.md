# 数据库隔离级别

## 事务不隔离会有哪些问题？

1. 脏写（严重问题，不能接受）：事务A先开启，事务B后开启，事务B修改某条记录的某个值提交后，事务A再次进行修改，此时事务A如果出错，回滚，导致事务B的修改丢失，事务执行结果受到其他事务的影响
2. 脏读（严重问题，不能接受）：事务A对某条记录的某个值进行修改后，并未提交，事务B此时进行查询，查询出来的值是事务A未提交的值（可能会回滚），看到了其他事务的操作
3. 不可重复读（属于问题，但是在使用中大多数认为可以接受）：事务A开启对某条记录进行查询，此时值为1，事务B对该记录进行修改，将值修改为2，并且事务B提交，此时事务A再次对该记录进行查询，此时值为2，在同一个事务里面多次读取数据不一样，看到了其他事务的操作
4. 幻读（属于问题，但是在使用中大多数认为可以接受）：事务A开启，对某个表进行数据查询或计数，事务B又insert了一些新纪录并提交，此时事务A再次做相同操作，发现多出几条数据，就像出现幻觉一样，这是因为受到了其他事务的影响

## sql中的四种隔离级别	

sql标准中认为出现这四种情况的问题严重程度排序如下：脏写 > 脏读 > 不可重复读 > 幻读。所以sql标准设立了如下四个隔离级别：

1. READ UNCOMMITTED：读未提交，在该隔离级别下，可以读取到其他事务未提交的执行结果。不能避免脏读，不可重复读，幻读
2. READ COMMITTED：读已提交，在该隔离级别下，只能读取到其他事务提交了的数据。它解决了脏读问题，并未解决不可重复读，幻读
3. REPEATABLE READ：可重复读，事务A读取到某条记录之后，事务B对该记录进行修改并提交，事务A再次读取，值不发生改变。它解决了脏读，不可重复读，并未解决幻读
4. SERIALIZABLE：可串行化，一个事务开启后，其他只能等待该事务提交完毕之后才能开启。它解决了脏读，不可重复读，幻读

至于脏写这四种隔离级别都不允许出现

