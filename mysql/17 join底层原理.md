# join底层原理

当A表joinB表时：

如果两表都没有索引，那么现象为小表驱动大表，如果有一个表的连接字段有索引，那么该表会成为驱动表，如果两表都有索引，那么又回归为小表驱动大表。

使用join表进行表连接时，在5.5之前使用的是**嵌套循环**算法，如果关联表数据量很大则关联执行时间会非常长，5.5版本之后通过引入BNLJ算法来优化嵌套执行。

**注意：所谓驱动表和被驱动表是指，两表连接时，使用explain分析打印，在上面的是驱动表，下面的是被驱动表**

在A join B时，A不一定就是驱动表，谁作为驱动表还要看查询优化器做出的决定

在A left join B时，如果查询优化器没有将我们的sql改造为内连接，那么可以说A表是驱动表，如果优化器改造为了内连接，那么谁作为驱动表就不一定了（right join也一样）

### SNLJ（simple nested-loop join）

SNLJ，简单嵌套循环，在两张表都没有索引的时候，会简单的将A表遍历，拿A表中的一条数据到B表中进行全表遍历匹配，直到A表中所有记录都完成为止。

所以mysql会采用一些优化，使用结果集小的表作为A表，结果集大的作为B表，使外侧大循环的次数变少，这就是**小表驱动大表**

### INLJ（index nested-loop join）

INLJ索引嵌套循环，故名思义，假如其中有一个表的连接字段有索引，那么在进行匹配时会将有索引的表作为被驱动的表（内层循环的表），因为这样做比起作为外层循环而言明显可以过滤掉更多的数据（假如有索引的表作为外部循环，那么索引完全用不上）

### BNLJ（block nested-loop join）

在没有索引的时候，使用的是SNLJ的方式，这种方式太过原始，IO次数过多（每次都从驱动表中拿一条数据去与被驱动表匹配）。所以引入了join buffer这一机制，它不再一条一条地读取驱动表的数据，而是一次加载一块。加载的数量受join buffer影响，而在比较时被驱动表与join buffer中的所有记录进行比较。这样就将多次匹配合并成了一次匹配，减少了被驱动表访问的频率。