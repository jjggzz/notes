# 怎样做主键设计

## 自增id有什么问题？

1. 容易被猜想id的值，因为是有序的，所以容易被爬虫爬取
2. mysql的自增id存在回溯的问题，直到8.0才修复
3. 性能差，依赖于myql数据库服务（猜想里面应该有锁）
4. 如果想知道插入记录的id值，那么需要额外的使用last_insert_id()函数进行查询，需要多一次数据库交互
5. 只在表中唯一，不是全局唯一，如果数据量大起来需要进行分表，甚至分库，那么可能存在问题

## 使用业务字段做主键？

比如说一张表里面有会员卡号、电话号码、身份证号等等信息，如果不选择用自增主键，从这里面选可不可以呢？

虽然这些字段可以表示唯一，但是业务层面发生的变化，可能导致一些其他情况。拿会员卡号来举例的话，有可能业务迭代出现卡号复用的情况，拿它来做主键就有可能造成数据污染的问题，因为可能前一个用户的记录会被后面复用的用户查询出来，不太适合做主键。

电话号码、身份证号等字段属于敏感信息，那么后续业务迭代有可能变成允许为空的情况，或者说压根就不要求用户必填，这种情况不可控，也不太适合做主键。

## 主键应该怎么设计呢？

在现如今分布式大行其道的情况下，主键需要满足两个基本的要求：**全局唯一，单调递增**

全局唯一这一要求无需多言，这是最基本的要求，而单调递增则是考虑到性能方面的问题，在mysql中如果主键是单调递增的，那么在聚簇索引插入时就是在后续追加即可，如果无序，那么情况就会很糟糕，会出现频繁的页分裂，从而影响效率。

还要可以从业务角度考虑，一些操作记录表、日志表等不是很重要的表可以考虑使用自增id因为这样最简单，而关键业务则不能如此，比如说订单表这种。

就数据库层面而言，mysql8.0里面有一种uuid的主键策略，它可以是有序的，如果使用它也能够实现上述要求，但是，还是避免不了mysql生成主键，业务层想要知道需要额外交互的问题。

业务层的角度而言生成主键似乎是一种比较好的选择，毕竟不需要消耗mysql的资源，而且算法可以由用户控制（比如在订单主键的后面追加用户的编号）好的方案现在有很多：

**雪花算法**。但是它也有缺陷，比如依赖服务器时间，如果时间回拨则可能出现重复值。很多开源框架都用到

**基于双buffer的mysql的区间段号**。实现原理为在mysql中创建一张表，这张表有biz_code、max_id、setup等字段，其中biz_code代表着业务表的编号，max_id代表当前结点的最大id，setup代表生成的步长，业务结点获取主键时获取一个步长的主键放到内存中，这样就可以减少数据库的访问次数。但是如果服务中只有一个主键buffer，那么在用完后请求数据库拿主键的时候可能会出现抖动，可以使用两个buffer，当一个buffer中的主键快不够用的时候就去请求，然后放到另一个buffer中，供后续使用。阿里的TDDL有一部分服务就是基于它实现的

