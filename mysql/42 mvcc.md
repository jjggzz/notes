# mvcc

MVCC（Multi-version concurrency control，多版本并发控制）是为了解决传统锁理论解决事务隔离级别性能低下的问题，它主要的思想是**维护一份数据的多个版本**，并发下不同的事务都有自己的readview，可以看到不同版本的数据，正在写的事务不会影响到读取的事务，实现并发的**一致性读**，这种读历史版本的行为称为**快照读**，与其对应的读取数据的最新版本称之为**当前读**

## mysql的事务隔离级别

事务隔离级别的理论定义：

|              | 脏读 | 不可重复读 | 幻读 |
| ------------ | ---- | ---------- | ---- |
| **读未提交** | 是   | 是         | 是   |
| **读已提交** | 否   | 是         | 是   |
| **可重复读** | 否   | 否         | 是   |
| **串行化**   | 否   | 否         | 否   |

而在mysql中是这样的（可重复读隔离级别下，MVCC解决快照读的脏读、不可重复读、幻读，使用临键锁解决了当前读的脏读、不可重复读、幻读）：

|              | 脏读   | 不可重复读 | 幻读   |
| ------------ | ------ | ---------- | ------ |
| **读未提交** | 是     | 是         | 是     |
| 读已提交     | 否     | 是         | 是     |
| **可重复读** | **否** | **否**     | **否** |
| **串行化**   | 否     | 否         | 否     |

## mysql中的MVCC

mysql中的MVCC实现是由行记录中的两个隐藏字段（trx_id，roll_pointer）、undo log日志、视图（readview）组成。

- roll_pointer+undo log日志构成了数据的历史版本链

- trx_id+readview构成了事务的可见范围

历史版本链逻辑结构如下：

| 数据 | trx_id | roll_pointer |
| ---- | ------ | ------------ |
| .... | 10     | ⬇️            |
| .... | 5      | ⬇️            |
| .... | 3      | ⬇️            |
| .... | 1      | null         |

其中trx_id，代表修改这条数据的事务id，roll_pointer指向前一个历史版本的数据，这些历史版本在undo log中，mysql会在合适的时候将它们清理回收。一条新数据它的roll_pointer是null（insert产生的回滚记录在事务提交时就可以删除，没有保留的必要），事务在快照读的时候就沿着这个版本链寻找它可以看的数据。

readview由几个属性组成：

1. create_trx_id，创建这个readview的事务id，如果这个事务是个只读事务，那么这个值为0，只有在insert、update、delete时才会分配事务id
2. trx_ids，创建这个readview这一刻mysql中所有活跃的事务id列表（未提交的）
3. up_limit_id，活跃事务列表中最小的事务id
4. low_limit_id，生成readview时，系统中可以分配给下一个新事务的id值（事务id是递增的），**这个值并不是活跃事务列表中的最大值**，因为有些事务有可能后开启，反倒先提交

事务在聚簇索引中找到数据之后根据这条记录的trx_id字段的值，通过readview来判断这个值是否可见，不可见则追溯历史版本，直到遍历完整个历史版本链，具体判断规则如下：

- trx_id等于create_trx_id，说明这条数据就是由当前事务修改过的，这条数据可见，返回它。

- trx_id小于up_limit_id，说明这条数据在生成readview的时候就已经由其他事务提交了，这条数据可见，返回它。

- trx_id大于low_limit_id，说明这条数据是由生成readview之后的某个新事务所修改的，不可见，向前追溯历史版本，再次对比trx_id

- trx_id既大于up_limit_id，又小于low_limit_id，此时就没法简单的直接断定它的可见性，此时判断trx_id是否存在于trx_ids中，若在，代表生成readview时，修改这条数据的事务还未提交，不可见，向前追溯历史版本，再次对比trx_id，若不在，代表生成readview时，修改这条数据的事务已经提交，可见，返回它

## 总结

根据上面的规则，快照读就可以解决脏读，不可重复读，幻读的问题了。

1. 如果某个事务在还在修改，那么即使修改了trx_id，只要没有提交，其他事务只会认为不可见，会往前读历史，从而避免了脏读。
2. 如果某个事务已经提交，修改了trx_id，只要readview不发生改变，依旧会认为这条数据不可见，多次读取看到的结果是一致的。
3. 如果某个事务新增一条数据并提交，产生的效果和第二点一致

所以，mysql在READ-COMMITTED隔离级别每次查询都重新生成readview，因此他解决了脏读，但是第二次查询可以看到其他事务提交后的数据，所以并没有解决不可重复读和幻读

在REPEATABLE-READ隔离级别下，第一次查询的时候生成快照readview，之后都是查询这个快照所以它不会发生脏读、不可重复读、幻读的问题



