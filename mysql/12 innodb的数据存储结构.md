# innodb的数据存储结构

在innodb中，磁盘和内存的数据交换都是以**页**（页中会有多个数据行）为单位进行交换的（基本单位）。innodb将数据划分为页，每页大小默认**16KB**。

它在读取数据的时候即使可能只需要一条数据，它也会把整个数据页加载到内存中。在刷盘时也是以页为单位进行刷盘（毕竟每次只操作一条数据太慢了）。

## 页内部的结构

页与页之间**可以不在物理磁盘上相连**，只要**通过双向链表相连**即可。每个数据页中的**数据行组成单向链表**。每个数据页都会为它内部的记录生成一个**页目录**。在通过主键进行查找时，在**页目录中使用二分法**快速定位到对应的槽，然后遍历该槽对应分组中的记录即可快速找到指定的记录。

页按照类型进行划分可分为：数据页、系统页、undo页、事务数据页。

数据页空间被划分为七个部分：文件头、页头、最大最小记录、用户记录、空闲空间、页目录、文件尾

## 行结构

数据行记录之间是紧密的排列在一起的（物理上也是连续，这也是为什么删除数据时只是修改一下delete_mask的值，而不是进行数据移动），逻辑上是用链表相连。

记录头信息：

delete_mask：删除标志位，如果数据被删除，则该位会被设置为1，它占用一个二进制位

min_mask：B+tree的每层非叶子结点中的最小记录都会被设置为1，它占用一个二进制位

record_type：0代表普通记录、1代表非叶子结点记录、2表示最小记录、3表示最大记录

heap_no：表示当前记录在本页中的位置。我们自己的数据是从2开始的，这是因为mysql会在页内自己弄两条记录，一条heap_no为0一条为1，代表着最小和最大两条记录。

n_owend：行记录会被分组，而这一组中有多少条数据就记录在当前组中主键最大的行记录的这个字段中

next_record：它表示到下一条记录的真实数据的**地址偏移量**，所谓的下一条记录并不是按照我们插入顺序的下一条记录，而是主键值由小到大排列的下一条。并且规定了heap_no为0的下一条是本页中主键最小的记录，本页中主键最大的下一条是heap_no为1的记录。



当数据被删除时，被删除记录的前一记录的next_record值会修改为被删除记录的后一条记录的位置（类似于链表的删除），被删除的记录的next_record值会被设置为默认值、delete_mask会被设置为1，并且它会加入到垃圾链表，以备后续重用，在数据新增时，只要主键相同，那么会重新使用被删除数据的那部分空间

## 页目录

定位到数据行所在的页后，如果想要继续找到记录所在的位置，如果没有其他手段，那么查询效率为O(n)，效率比较低下。所以mysql引入了页目录进行查询优化。

所谓的页目录就是将数据进行分组，然后提取每组最大的值的地址，将其选入页目录，在查找时使用二分法就可以很快确定数据在哪个组中，从而排除掉大量数据（可以理解为稀疏索引、跳表的玩法）。

