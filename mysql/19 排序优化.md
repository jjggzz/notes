# 排序优化

在order by的情况下，如果排序字段没有索引，那么可能会使用filesort文件排序，而文件排序**大多数**情况下是要比使用索引慢的。

**如果在排序字段上加上索引，就可以避免文件排序了（5.7没有倒序索引），推荐是where条件了order by条件一样的话使用单列索引，如果不一样使用联合索引，where条件放前面**

对于一些小部分的情况：

```sql
## 联合索引为 age,salary
## 这种情况，不会出现filesort
select * from temp where age = 18 and id < 1000 order by salary;

## 联合索引为 age,id,salary
## 这种情况，即使出现filesort也不见得比上一种情况慢
## 原因就是过滤出来的数据量的问题，第一种情况，虽然age,salary都用上了索引，但是参加过滤的只有age字段
## 第二种方式参加过滤的字段却有age和id，那么第二种情况明显能够过滤出更少的数据，即使因为id是范围查询导致salary失效，需要进行文件排序，由于结果集小的原因反而效率高
## 第一种虽然不用进行排序，但是可能查询出非常多的数据，然后回表去过滤id < 1000的值，从而降低了性能
select * from temp where age = 18 and id < 1000 order by salary;
```

注意：所有排序都是在过滤完成后进行的，如果得到小的结果集，即使进行文件排序也不会见得多慢

那么在没有办法优化filesort的情况下如何提高效率呢？我们可以调高sort buffer的大小，让mysql能够一次性读取更多的数据进行排序操作减少IO次数

而在order by的时候查询的返回列还有说法。不要使用 select * ，尽量只查询需要的列。因为在filesort的时候会根据返回的数据大小与max_length_for_sort_data对比（排序字段不是text、blob时），如果比它小，则使用改进后的单路排序（读取所有返回字段，一次排序，无需回表），否则使用老算法双路排序（读取排序字段，排完序之后回表拿剩下的数据）