# 事务日志的总结

## 事务执行流程

1. 开启事务，会向rollback segment申请一片空间用来存放undolog
2. 执行修改语句，此时先写一条undolog日志到undolog buffer
3. 将这条undolog引起的磁盘修改写入redolog buffer中（保证undolog的持久性，系统突然挂掉也能保证undolog写入成功，在系统重启时重放redolog进行数据写入，然后通过undolog来回滚未提交的事务）
4. 修改data buffer pool中数据页的中的值（这些脏页有可能在事务还没提交时就被刷入磁盘了）
5. 将这次数据页修改引起的磁盘修改写入redolog buffer中（保证数据的持久性）
6. 提交事务时根据innodb_flush_log_at_trx_commit值的不同，redolog buffer的操作有以下几种情况
   1. 值为0：没有其他多余操作，等待后台的线程将redolog buffer中的内容写入os页面缓存，并调用flush()将数据持久化到磁盘中，频率为1s一次
   1. 值为1：将redolog buffer中的内容内容写入os页面缓存，并调用flush()将数据持久化到磁盘中
   1. 值为2：将redolog buffer中的内容写入os页面缓存，由操作系统决定什么时候持久化到磁盘中

## 理论

对于**使用缓存**提高读写性能的本地在线事务处理系统，保证数据持久性和原子性有几种策略。

steal：在事务执行过程中，允许将发生变更可能回滚的数据刷入磁盘

no-steal：在事务执行过程中，不允许将发生变更可能回滚的数据刷入磁盘

force：在事务提交的时候，强制将发生变更的数据刷入磁盘

no-force：在事务提交的时候，不强制将发生变更的数据刷入磁盘

|          | steal                                              | no-steal                                           |
| -------- | -------------------------------------------------- | -------------------------------------------------- |
| force    | 系统崩溃可能写入脏数据，强制刷盘性能差             | 系统崩溃不会写入脏数据，强制刷盘性能差             |
| no-force | 系统崩溃可能写入脏数据，不强制刷盘可能造成数据丢失 | 系统崩溃不会写入脏数据，不强制刷盘可能造成数据丢失 |

在事务执行过程中，是否允许将发生变更可能回滚的数据刷入磁盘影响刷盘策略的设计，如果允许，则刷盘策略设计较为简单，只需要后台起一个线程定时将脏页刷盘即可，不用关心这个数据页里面的修改有哪些是未提交的事务修改的，但是为了处理突然崩溃造成的脏数据需要引入undolog来进行数据恢复（**steal/no-steal影响缓存子系统设计的复杂度**）

在事务提交时，如果强制进行刷盘，则性能低下，因为无法确定修改了哪些数据页，所以对磁盘的写入是随机IO，性能低。如果不强制刷盘，采用异步刷盘机制，性能高，为了处理突然崩溃造成的数据丢失，需要映入redolog来进行日志记录，只要保证redolog成功写入磁盘，即使突然崩溃，在系统恢复时依旧能够依靠redolog来进行数据恢复，由于redolog是顺序写，即使同步刷盘性能也不会低（**force/no-force影响系统性能**）

mysql基于steal no-force的方式开发，这样缓存子系统的设计会比较简单，并且系统性能高。由于引入了undolog和redolog，在系统崩溃恢复时需要花费额外的时间对数据进行恢复，但是这是可以接受的，只是系统启动稍微慢点