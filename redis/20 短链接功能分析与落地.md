# 短链接功能分析与落地

## 业务需求分析

短链接功能大致如下：

1. 给一个长链接，将其转换为短链接（这里需要一种算法来转换）
2. 需要有一个地方保存这种映射关系
3. 访问短链接之后，可以跳转到对应的长链接

## 实现方式

这里的关键点在于转换的算法和映射关系的保存，至于跳转可以使用重定向将请求转过去。

转换算法有两种比较流行的：

1. 一种是基于递增数的映射，将长链接对应到某个数，在将这个数转化为短链接，这样的算法不存在冲突，但是短码的长度随着数字的变大会变长
2. 一种是基于摘要的算法，将长链接进行md5加密后获得一个32位的串，将它分为4段每段8位，将某一段与0x3FFFFFFF（30个1）做与运算，获取低30位，再将这30位分为6段，每5位映射到字母表，这样就可以得到一个长度为6的字符串。一个长链接可以得到4个短链接，任选一个即可（新浪用的就是这种）

如果基于数据库做映射关系，使用自增序列是比较好的，但是在分库分表的情况下需要一个全局发号器。

如果是基于redis的hash做映射关系，可以考虑直接使用摘要算法获取短链，直接存储到hash。

从实现难易程度上来考虑的话无疑是redis的更为简单，并且可以承受较大的并发，如果是基于数据库的实现并发上来之后还是要引入缓存减压，所以**采用redis是非常不错的**。

## 实现伪代码

短链接生成:

```tex
func(string longUrl) string {
	string shortUrl = calcShortUrl(longUrl);
	redis.hset("longshorturlmap", shortUrl, longUrl);
	return shortUrl;
}
```

页面跳转

```tex
func(string shortUrl) {
	string longUrl = redis.hget("longshorturlmap", shortUrl);
	redirect(longUrl);
}
```

