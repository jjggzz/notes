# redis九大数据类型与落地

## redis九大数据类型

redis更新6.x版本已经拥有了九种数据类型了，分别是：

1. string
2. list
3. set
4. zset
5. hash
6. bitmap
7. geo
8. hyperloglog
9. stream

## string类型落地

redis的string类型作为最基础的类型，除了做kv缓存以外，**基于SETNX命令可以实现分布式锁**功能，**基于INCR命令可以**实现**浏览量、点赞数、pv统计**等数字累加的功能。

**需要注意的是使用INCR来实现浏览量的统计，在超高并发下并不好用，会占用redis服务器cpu的大量 时间做自增操作影响其他命令的执行，一个解决办法是判断这个数的值，如果超过了某个阈值则什么都不做，否则进行数量的累加，这是一种保护redis的办法**

## map类型落地

redis的map类型再形式上有点类似于java的Map<String,Map<String,String>>结构，可以用它来**实现购物车**等功能。

1. 具体的就是外部key为用户编号，内部的一个个key是商品编号，而value则是数量
2. 每当用户增加商品时使用HINCRBY命令将数量增加
3. 使用HGETALL可以遍历购物车
4. 使用HDEL可以删除某个商品

redisson实现分布式锁是由map+lua实现的

## list类型落地

redis中list是一个双端链表结构，容量是2的32次方减一个元素，由于可以简单的操作头尾（pop、push），可以用它来模拟栈、队列等场景。可以用它来模拟**订阅消息、评论列表**等功能。

订阅消息实现方式（类似消息查看的功能都可以）：

1. 张三关注了一些作者，每当这些作者发布文章，就使用RPUSH将文章编号添加到队尾
2. 张三每次浏览自己的推送列表时使用LRANGE进行浏览，可以使用参数指定返回多少条，实现分页功能

评论列表实现方式（感觉不是很好，商品评论多的话感觉会炸）：

1. 对于某个商品的评论都可以使用RPUSH将其塞到队列里面，key就是商品编号，value就是评论内容
2. 评论浏览时使用LRNGE进行浏览

## set类型落地

redis的set类型中的元素是无序的，由于他提供了随机获取一个或多个元素的功能（删除SPOP或者不删除SRANDMEMBER）可以用它来做一个**简单抽奖功能**，具体的：

1. 每当一个用户参加抽奖，则将用户编号使用SADD加入到set中
2. 当进行抽奖时，根据需求使用不同的命令对元素进行随机获取

**朋友圈点赞**：

1. 每当有用户对某条朋友圈点赞时，使用SADD将其用户编号加入到set中
2. 当用户取消点赞时使用SREDM将该用户编号从set中移除
3. 可以通过SCARD统计有多少人进行过点赞
4. 判断是否进行过点赞可以使用SISMEMBER，要查看所有的点过赞的人可以使用SMEMBERS

redis的set还提供了集合运算等功能（交集SINTER、差集SDIFF、并集SUNION），可以用他们来实现：

**共同关注**：

1. A关注了BCD，F关注了BCE
2. 使用SINTER就可以得到他们共同关注的人BC

**你可能认识的人**：

1. A的好友列表里面有BCD，B的好友列表里面有ACE
2. 由于他们是好友关系，可以使用SDIFF用B的好友列表减去A的好友列表，就得到了A可能认识的人（AB互为好友，B的好友可能就是A认识的人）

**猜你喜欢**：

1. A喜欢商品123，B喜欢的商品12345
2. 可能后台经过分析，大部分用户喜欢123的都会喜欢45，那么就做一个差集，可以猜用户A喜欢的东西而不是随机给出

## zset类型落地

redis的zset类型是带有排序功能的，同时也具有set的去重功能，可以用它来实现**排行榜**（不用多说），真实案例的话jlc的派单操作

## bitmap类型落地

redis的bitmap由于其占用空间小、只有0和1两个值的特性非常适合用来做**签到或者日活统计**，也可以用来做**布隆过滤器**

签到统计：

1. 使用setbit为某个用户设置bitmap，例如setbit user001:202301 0 1，代表2023年一月第一天是签过到的
2. 依此类推，每次签到就将对应的位置设为1
3. 使用bitcount可以知道某个用户在某个月的签到天数
4. 遍历获取某个用户的签到信息，根据对应位的值可以知道具体是哪些天缺勤

日活统计（DAU、MAU）：

1. 在redis中使用一个bitmap，key的名字就叫sign:20230131，代表着2023年一月31日这一天系统用户的签到情况
2. 在数据库中为每个用户做用户id与bitmap位的映射
3. 在用户进行签到时，根据映射关系，将对应的bit为设置为1
4. 只需要使用bitcount来统计sign:20230131，就能知道这一天有多少用户进行过签到
5. 同样的也可以根据对应位的信息来判断这一天这个用户有没有签到
6. 特别的，可以使用bitop将一个月的key使用and处理，这样就可以知道哪些用户非常活跃，连续一个月都进行过签到

布隆过滤器（**主要是解决缓存穿透的问题，在攻击者查询不存在的key时不打到数据库**）：

1. 将数据库中的数据按照规则（一般是多个hash函数）将查询键做位映射（可能有多个位，取决于规则）
2. 在redis的bitmap中将得到的那些位设置为1，直到所有的键都被处理并放入bitmap（将键经过hash函数处理后，所对应的位置如果全为1则布隆过滤器认为存在，否则认为不存在）
3. 在进行查询时，首先去询问布隆过滤器，查询键是否存在，如果它认为存在则查询缓存，它认为不存在直接返回空
4. 对于巧合穿过布隆过滤器的请求，但是缓存和数据库中也没有数据，可以考虑在缓存中缓存该键，，值设为空，并设置过期时间，下次来就不会打到数据库了
5. 布隆过滤器的特点是：说不存在则一定不存在（有位置不为1，代表这个键肯定不存在），说存在可能不存在（巧合的将对应位设置为了1）
6. 布隆过滤器的中最好不要删除元素，删除元素会使误判率变高（删除的位其他的查询键也用着，设置为0后导致存在的数据认为不存在了）

## hyperloglog类型落地

hyperloglog天生就适合做日活统计，uv统计的实现，由于它是一个近似值，存在0.81%的误差，并且只能够得到一个数字，所以不能像bitmap那样完全精确，但是在空间消耗方面极少，适合海量数据的统计，对于uv统计的业务，也没有必要知道到底哪个用户访问过，统计值即可。

1. 使用当天的时间标识作为key使用pfadd将访问的客户端的标识添加进去
2. 使用pfcount就可以统计到底有多少个客户端访问过，这里得到的数据是去重过的
3. 可以使用pfmerge命令合并多天的uv从而统计周、月、年的uv

## geo类型落地

geo这个类型一出世就是为了解决地理位置相关的业务的，使用它可以很简单的实现附近位置搜索，比如**附近车辆、附近超市**等等位置搜索功能。
