# 抢红包功能分析与落地

## 业务需求分析

抢红包功能流程大致如下：

1. 用户可以发红包
2. 红包的总金额和个数确定后每个红包的金额需要一种策略来计算（完全均分？二倍均值？完全随机）
3. 为1对多关系
4. 用户抢红包，不允许用户重复抢，所以需要记录用户抢了多少
5. 红包到期未抢完的回退给发红包的人

## 实现方式

### mysql

1. 建立红包主表，存储是谁发的红包，什么时候过期等等
2. 建立红包金额表，存储每个红包的金额以及是否被抢过，如果被抢是被谁抢的
3. 用户发红包的时候将信息插入到红包主表，通过算法计算好每个红包的金额后存储到红包金额表
4. 默认情况下红包都是没有被抢过的
5. 用户进行抢红包操作的时候，查询这些红包中是否有红包是我抢过的，如果有则直接退出
6. 没有的话就将未被抢红包中的一个设置为自己
7. 由于这里是并发操作的，所以要加锁处理，否则明明A抢成功了到后面却被B覆盖了

### redis

1. 用户发红包时指定金额和个数之后通过算法计算每个红包的金额大小
2. 将所有红包RPUSH到一个list中，返回这个key
3. 需要有一个hash存储抢过这个红包的用户
4. 用户进行抢红包的时候，先从hash判断自己是否抢过，如果抢过直接结束
5. 如果没抢则直接从这个list中LPOP，如果有值代表抢到了
6. 将自己的用户id，红包金额数据HSET到hash
7. 抢红包业务关键并发点就在于红包的分配，至于记录金额，只有抢到了的才需要记录不存在并发问题
8. 由于redis天生单线程，对于抢红包的LPOP操作天生就是串行的，不存在线程安全问题

### 实现难易程度与性能分析

根据上述分析，不难发现，redis的实现是比较简单的，并且对于抢红包这种一定会有并发的业务支持更好，mysql使用锁也能够保证线程安全，但是它需要操作的是数据库，而redis直接操作内存，效率会更高

再从用户量上面来分析，如果抢红包这种业务非常多人使用，那么mysql可能扛不住那么大的请求量，毕竟是千级，而redis能够处理的请求量在万级，所以**redis胜出**。

## 实现伪代码

发红包：

```tex
func(number money, number count) string {
	// 计算金额
	number[] amounts = calcAmount(money, count);
	// 随机生成一个key
	string key = uuid.next();
	// 设置到redis
	redis.rpush(key, amounts);
	// 返回红包的key
	return key;
}
```

抢红包：

```tex
func(string key, string userId) bool, number {
	// 如果抢过了那么不能继续抢
	if (redis.hexist("record:"+key, userId)) {
		return false, 0;
	}
	// 如果没抢到则结束
	// 此处抢红包操作的线程安全redis以及帮我们保证了
	number money = redis.lpop(key);
	if (money == null) {
		return false, 0;
	}
	// 抢到了则记录
	redis.hset("record:"+key, userId, money);
	// 返回结果
	return true, money;
}
```