# 五大IO模型

首先要知道的是，数据从客户端发送到服务端之后，我们服务端的应用程序想处理这些数据必须经过两步：

1. 数据从网卡拷贝到内核空间
2. 数据从内核空间拷贝到用户空间

我们的应用程序只能处理用户空间的数据。由于需要经过上述步骤，应用程序在操作系统处理上述内容时的做法就演化了以下几种模型

## BIO（阻塞IO）

应用程序在发起读请求时，如果没有数据到达会**一直阻塞**，一直等待数据到达网卡，并**等待数据从网卡拷贝到内核空间、从内核空间拷贝到用户空间**。期间什么事情都不能做。只有数据到达时才从read函数返回。

可以看出这种IO模型的效率是比较低的，一次只能处理一个连接请求，在等待时，甚至不能处理新的连接，在新客户端看来就像卡死了一样。

怎么优化呢？可以考虑在每**个连接进入时，都开启一个新的线程去处理**，那么这些连接就会阻塞在单独的线程上进行一对一服务。

这样做是可以解决连接不能处理的问题，但是又引来了新的问题，比如**连接多了会创建大量线程、线程多了以后频繁的上下文切换非常影响性能、如果连接一直没有发送数据那么这些阻塞的线程就非常浪费**了

## NIO（非阻塞IO）

应用程序在发起读请求时，如果**没有数据到达，那么直接返回**，只有当数据到达内核后，才会阻塞的将数据从内核空间拷贝到用户空间。可以看到，这种IO模型在没有数据到达的时候会直接返回，并不会阻塞，只有数据到达的时候才会读取。

这种模型比起前面的阻塞式IO就好了很多，我们可以在客户端连接的时候就将它添加到一个列表中，然后轮训这个列表，去读取数据（没有数据会直接返回），这样就**可以用一条线程处理这些连接请求了**。

这种模型虽然好了一点，但是也有缺点，我们在循环调用read的时候对于每次read方法的调用都会发起一次系统调用，并且**这种系统调用是从用户态到内核态的**，这种系统调用效率不高。

## IO multiplexing（多路复用IO）

非阻塞IO让一个线程拥有了处理多个连接的能力，但是这种在用户态进行轮训的方式需要发起很多次系统调用，效率并不高，如果能够将这种**获取可读连接的操作让内核完成**，应用程序在一个阻塞对象上进行等待，当有可读的连接时，解除阻塞，效率肯定可以得到很大的提升。

而这种IO多路复用的思想在linux系统的落地就是select、poll、epoll这几个系统函数。

select、poll、epoll都是IO多路复用的落地实现。

select实现较为简单，它监听多个文件描述符（粗浅理解的话就是客户端连接），一旦有连接可读或者可写则从select处返回。**它需要应用程序自己遍历寻找是哪个连接就绪**，这样的操作是O(n)的，使用数组做载体，**支持1024个文件描述符的监听**，处理后还**需要再次传入监听的文件描述符**（也就是说每次处理完成之后再次监听会发生一次用户态到内核态到拷贝）

poll的事件与select基本相同，只不过是**将载体由数组换成了链表**（函数的参数要的是数组，但是在内部是将数组拷贝给了一个链表），这样就**没有数量限制**了，但是有连接就绪后还是需要应用程序自己遍历花费O(n)的时间复杂度，并且处理后也需要再次传入文件描述符

epoll实现就更加完善了，它提供了三个函数，epoll_create()、epoll_ctl()、epoll_wait()，使用epoll_create初始化一个具柄。使用epoll_ctl将文件描述符添加到监听，其实是添加到内部的红黑树。使用epoll_wait进行阻塞，一旦解除阻塞代表有事件就绪，它会将就绪事件放到一个链表的头部，并返回已经准备好的连接的数量，只需要遍历链表头部的对应数量的连接即可，相比前两种IO多路复用的实现，它更为高效，因为只需要一次将文件描述符拷贝到内核的操作（调用epoll_ctl）

## signal-driver IO（信号驱动式IO）

信号驱动式IO在read的时候如果没有数据到达会告诉内核，让内核在数据到达时通知我们，而我们现在可以去做其他事，当有数据到达时，通知应用程序，应用程序调用read将数据从内核空间拷贝到用户空间

## asynchronous IO（异步IO）

发起read请求后就可以继续往下执行，系统回调应用程序的时候所有的一切都准备好了（步骤1和步骤2都完成了）

## IO模型对比

异步IO和前4种IO不同，**前4种IO模型都会阻塞在内核空间到用户空间的数据拷贝上，而异步IO不会**。

对于前四种IO他们的不同则在于第一阶段：

1. 阻塞式IO对于第一阶段直接阻塞**一直等到有数据为止**。

2. 非阻塞式IO对于第一阶段的处理是如果**没有数据直接返回**。
3. 多路复用IO对于第一阶段的处理是阻塞，但是**它阻塞在一个对象上，这个对象监视着很多个连接**，一旦有某个连接有数据则解除阻塞
4. 信号驱动IO对于第一阶段的处理是不阻塞，直接返回，但是**它不用像非阻塞式IO那样一直去询问，而是等内核的信号**，有信号则代表有数据过来

