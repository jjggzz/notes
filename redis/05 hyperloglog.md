# hyperloglog

对于uv统计，首先要做的就是去掉重复统计，在一段时间内对于同一个访问者（代指，反正就是有身份标识的）的访问只计算一次，实现方案有很多。

容易想到的是**使用mysql实现**，具体的，使用一张表记录，每当客户端访问时就往里面塞条访问记录，在统计时，如果统计pv，则直接count，如果统计uv则使用distinct去重。但是这样做**在大数据量、高QPS的场景下不适用**，每次请求都会访问一次mysql做记录，会导致mysql被打死。每一天的访问记录都很大，时间长了磁盘可能都不够用。

那么**使用redis的set或者hash实现**行吗，每次访问时都将客户端的标识使用sadd到set中，然后统计时使用scard获取其数量。这么做看似能够实现，但是由于redis是内存数据库，在**大数据量的情况下不行**，会导致set非常大，redis的内存肯定会被打爆。

如果**使用redis的bitmap+mysql实现**，具体的，使用mysql的一张表来记录客户端在bitmap中对应的位，由于这种映射是唯一的，不会重复，所以磁盘消耗可以接受，然后在访问时，根据映射将对应bitmap中的位设置为1，最后使用bitcount就可以统计uv数了。这种情况可以极大的减少空间的消耗。但是还是会有问题。首先，需要访问映射表，需要消耗数据库的访问时间，当然这种情况可以考虑将映射表加入缓存，避免打到数据库。但是使用bitmap空间消耗也挺大的，假设**1000w的客户端，那么需要大概1M的内存，如果客户端更多的话内存占用会更高，这还只是统计一个key，如果想持续统计，那么内存方面就不可以接受了**

**使用redis的hyperloglog实现**，hyperloglog使用近似算法对数据进行基数统计，仅仅使用12K的内存就可以统计2^64^个不同的键，误差率仅在0.81% （1.04 / sqrt(16384)）。非常适合用在大数据量下uv统计等场景。由于他的上限是2^64^客户端不可能超过这个数。所以可以放心的使用，hyperloglog只能往里面塞值，不能删除值也不能获取值

## hyperloglog的使用

```shell
## 向20220201中加入多个值，如果存在则计数器不会增加
6379> pfadd 20220201 client1 client2 client3
## 统计20220201中的基数数量
6379> pfcount 20220201
## 将20220201 20220202 20220203合并到202202中，202202的值是他们的并集
6379> pfmerge 202202 20220201 20220202 20220203
```
