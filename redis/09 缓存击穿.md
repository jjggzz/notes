# 缓存击穿

## 缓存击穿的表现

某个热点key突然失效（过期或者人为删除再重建），造成大量的请求打到数据库，威胁到数据库。

## 缓存击穿的危害

如果是高并发量的请求，所有请求都依赖缓存中的某个key，如果突然失效，数据库就遭殃了（参考聚划算的场景，24小时都有大量的人在访问，在某一时刻这个key突然不能从缓存中获取了，请求全部打到数据库，则数据库死掉）

## 如何解决缓存击穿的问题

**双重检查锁。**

1. 在缓存失效时，对该key进行加锁，并在临界区内部再次检查缓存，不存在则去数据库加载
2. 这样只会有一个请求打到数据库

双重检查锁确实能够解决缓存击穿的问题，但是在超高并发情况下，不太适用，毕竟有加锁操作，那么这些同时获取不到数据的请求都会进行锁的等待，这就变成了串行，不太好。

**不设置过期时间。**对于某些特别的key最好就不要设置过期时间了，这样就不会有请求打到数据库中了。

**但是如果需要对key进行重建，则这种办法就不不好用了，因为必然存在key不在缓存中的时刻。**

**提前关闭入口。**这个办法是可行的，关闭入口流量，重建后在打开入口，但是业务方不一定能够接受（参考聚划算案例，关闭入口的每一分钟都在损失）

**双key差异更新。**在无法关闭入口的情况下对key进行重建使用这种方法是可行的。（聚划算落地方案）

1. 在缓存中搞A、B两个key，两个key的内容相同
2. 在高并发的查询入口，先对A进行查询，如果A不存在则对B进行查询，如果都不存在则查询数据库（保底）
3. 在重建端，先对B进行重建，此时A还活着，请求打在A上，不会打到数据库
4. 再对A进行重建，A被干掉的时候，请求会打在B上，也不会打到数据库，等A重建完成后请求又会打在A上



