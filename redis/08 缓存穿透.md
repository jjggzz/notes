# 缓存穿透

## 缓存穿透的表现

正常情况下，数据库中的数据查询量大的话会将其加载到缓存，当客户端发起请求时，首先会从缓存中查询，若查询不到则去数据库中查询，查询到了则再次放入缓存，提供给后续查询使用，若数据库中还是没有则返回空，**这种缓存查询不到，去数据库中查询的情况称为一次缓存穿透**。

## 缓存穿透带来的危害

缓存穿透是系统的**高危隐患**，因为只要发生穿透，则请求必然打到数据库，不管是用户正常通过输入框数据，还是人为恶意攻击，只要是大量穿透请求过来，超过了数据库的处理极限则必然导致系统性能急剧下降，甚至会导致系统不能为外部提供服务。

## 如何防止发生缓存穿透

首先要明确，缓存穿透的发生，有可能是单个不存在的key遭到大量查询引起的穿透，更高级一点的是大量不同的key遭到查询，即使每个只查一次对数据库的威胁也是极大的。解决方法有下面两种：

**对于不存在的key，在缓存中缓存一个空值，设置过期时间**。

1. 用户提交不存在的key进行查询
2. 先查询缓存，不存在，对key进行加锁
3. 进入临界区后再次尝试从缓存获取值，如果有则返回（双重检查，高并发下只有一个请求会到数据库）
4. 如果还是没有则查询数据库，此时如果有则缓存数据，如果没有也缓存一个空值（缺省值），设置过期时间
5. 后续请求只会打到缓存的key上

上述解决方案可以解决单个key的穿透问题，但是如果是大量不存在的key请求过来，这种方式形同虚设（原因就是锁加在key上，只能保证对那个key的数据库查询只有一次），如果每次key不同，则这些请求都会打到数据库。

**引入布隆过滤器，进行数据存在性的判断。**

1. 在系统预热时，在将数据库中数据加载到缓存时，也往布隆过滤器中写入
2. 当用户提交key进行查询时需要去布隆过滤器中进行判断
3. 如果布隆过滤器认为不存在，则直接返回
4. 布隆过滤器认为存在则进行缓存查询，不存在则查询数据，还是不存在则返回空
5. 布隆过滤器的误判率是比较低的，偶尔发生几次也能够接受，实在不行则可以考虑对这种key缓存空值并设置过期时间
6. 在数据库中有数据新增时，需要往布隆过滤器中写入，保证布隆过滤器一定能够返回存在
7. 当数据被删除时，切记不能删除布隆过滤器中的数据（一般也不会提供删除的操作），因为这样会出现误判bug
8. 由于布隆过滤器中不能删除数据，那么运行久了之后考虑重新加载布隆过滤器，减少误判率

